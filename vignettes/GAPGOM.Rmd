---
title: "Introduction to GAPGOM"
author: "Casper Peters"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Citation

When using GAPGOM, please cite the following;

- Ehsani R, Drablos F: **TopoICSim: a new semantic similarity measure based on gene ontology.** *BMC Bioinformatics* 2016, **17**(1):296). DOI: [https://doi.org/10.1186/s12859-016-1160-0](https://doi.org/10.1186/s12859-016-1160-0)
- Ehsani R, Drablos F: [UNPUBLISHED] **Measures of co-expression for improved function prediction of long non-cofing RNAs**, 2018.

## Introduction

GAPGOM (novel **G**ene **A**nnotation **P**rediction and other **GO** **M**etrics) is an R package containing various tools and algorithms for semantic distance/comparison calculations and various other measures. This package has been specifically made to predict annotation of gene functions of unkown gene(s). This is done by comparing them to other known genes (guilt by association), and basing analysis on correlated data.

In GAPGOM, two main semantic measurement algorithms are available; TopoICSim and lncRNApred. TopoICSim is GO topology based, while lncRNApred is based on expression value distances.
The main interface for expression data as of right now is the fantom5 data, using Bioconductors `ExpressionSet` class. All algorithms are dependent on the GO consortium and thus use GOSemSim for loading GO data.

## Expression data interfaces

### ID support

As of v0.2.7 and up, all [AnnotationDbi]() IDs should be supported. However, we recommend usage of `EntrezID`s because this is the most widely supported ID in this and other packages. If you find issues in regards to ID support, please notify this issue on the package repository. If you have/want to convert IDs manually, the `BiomaRt` package is recommended. However, translating IDs to other types is lossy and doesn't always translate well.

### FANTOM5

As of right now, the package only has 1 main dataset for expression data; The Fantom5 dataset. There are a few helper functions to make this data usable. The Fantom5 dataset is only available for the human and mouse genome.

### Manually specifying an `ExpressionSet`

Because loading expression data right now is a bit limited, this paragraph will describe how to convert expression data to an `ExpressionSet` object. I will give an example with randomly generated expression values and IDs.

Minimal requirement for an `ExpressionSet`;

- expression values
- Unique IDs of a certain type. AnnotationDbi keys are the only IDs that are supported right now.

Each row of expression values should have corresponding IDs, with the ID-type as its columnname.

Random expression value generation;

```{r, eval=F}
# select 10000 random IDs
go_data <- GAPGOM:::.set_go_data("human", "BP", computeIC = F)
random_ids <- unique(sample(go_data@geneAnno$ENTREZID, 10000)) # and only keep uniques

# make general dataframe. 
expressions <- data.frame(random_ids)
colnames(expressions) <- "ENTREZID"
expressions$ID

# n expression values depending on the amount of unique IDs that are present
expressionvalues <- abs(rnorm(length(random_ids)*6))*10000
expressions[,2:7] <- expressionvalues
View(expressions)
```

Converting the expression dataframe to an ExpressionSet;

```{r, eval=F}
expression_matrix <- as.matrix(expressions[,2:ncol(expressions)])
rownames(expression_matrix) <- expressions$ENTREZID
featuredat <- as.data.frame(expressions$ENTREZID) # And everything else besides expressionvalues (preferably you don't even need to include the IDs themselves here!)
rownames(featuredat) <- expressions$ENTREZID # because they will be the rownames anyway.
expset <- ExpressionSet(expression_matrix, 
                        featureData = new("AnnotatedDataFrame", 
                        data=featuredat))

# To see how it is structured;
View(expset)
View(expset@assayData$exprs) # where expressionvalues are stored.
View(expset@featureData@data) # where other information is stored.
```

## lncRNApred

The lncRNApred (long non-coding RNA prediction) or `expression_prediction()` uses various methods/measures to determine similar genes; `pearson`, `spearman`, `kendall`, `sobolev` and `fisher`. These calculate scores between expressionvalue sets given a refrence gene. After this, these scores get enriched by an enrichment function, and will be sorted by significance before being returned. You can also try find all significant similar genes by using the `combined` method. The Sobolev and Fisher metrics are non-standard, all the others are standard methods from R's `cor()` function. The non-standard methods can be seen under this paragraph (quoted from paper [1], references edited);

### Sobolev metric

In this section, we use definitions and notations as in [2]. We start with the usual p-inner product. Let $f$, $g$ be real-valued functions (in this case $f$ and $g$ values are the expression vectors of two genes $f$ and $g$):

</br>
$\langle f,g\rangle_{p} = (\sum_{k=1}^{n}\mid f_k.g_k\mid^p)^\frac{1}{p}$        (2)

</br>
By this notation, Sobolev inner product, norm and meter of degree $k$ respectively can be defined by:


$\langle f,g\rangle_{p,a}^{S} = \langle f,g\rangle_p+\alpha\langle D^kf,D^kg\rangle_p$        (3)

</br>
$\mid\mid f\mid\mid_{p,k,\alpha}^S = \sqrt{\langle f,f\rangle_{p,\alpha}^S}$        (4)

</br>
$d_{p,k,\alpha}^S(f,g) = \mid\mid f-g\mid\mid_{p,k,\alpha}^S$        (5)

</br>
where $D^k$ is the $k$th differential operator. For the special case $p=2$ and $\alpha=1$ an interesting connection to the Fourier-transform of analysis can be made; let $\hat{f}$ be the Fourier-transform $f$

</br>
$\hat{f}(\omega_k) = \sum_{j=1}^{N-1}g_jexp(-i\frac{2\pi kj}{N})$        (6)

</br>
Where $\omega_k=\frac{2\pi k}{N}$ and $i=\sqrt{-1}$. Finally the norm can be written as

</br>
$\mid\mid f\mid\mid_{2,k,1}^S = \sqrt{\sum_{j=1}^{N-1}(1+\omega_j)^k\mid \hat{f}(\omega_j)\mid^2}$        (7) 

In this work metric (5) with norm (7) and $k=1$ was used.

### Fisher metric

In this section we use definitions and notations such as in [3]. To define Fisher information metric we first introduce the n-simplex $P_n$ defined by

</br>
$P_n=\{x\in R^{n+1}:\forall i, x_n \ge0,\sum_{i=1}^{n+1}xi=1\}$        (8)

</br>
The coordinates $\{x_i\}$ describe the probability of observing different outcomes in a single experiment (or expressino value of a gene in $i$th cell type). The Fisher information metric on $P_n$ can be defined by

</br>
$Jij = \sum_{k=1}^{n+1}\frac{1}{x_k}\frac{\partial x_k}{\partial x_i}\frac{\partial x_k}{\partial x_j}$        (9)

</br>
We now define a well-known representation of the Fisher information as a pull-back metric from the positive n-sphere $S_n^+$

</br>
$S_n^+=\{x\in R^n;\forall i,x_n\ge0,\sum_{i=1}^{n+1}x^2=1\}$        (10)

</br>
The transformation $T: P_n\to S_n^+$ defined by

</br>
$T(x)=(\sqrt{x_1}, \dots, \sqrt{x_n+1})$         (11)

</br>
pulls back the Euclidean metric on the surface of the sphere to the Fisher information on the multinomial simplex. Actually, the geodesic distance for $x,y \in P_n$ under the Fisher information metric may be defined by measuring the length og the great circle on $S_n^+$ between $T(x)$ and $T(y)$

</br>
$d(x,y) = acos(\sum_{i=1}^{n+1}\sqrt{x_iy_i})$        (12)

</br>
The lncRNApred method can also be used on other novel genes besides lncRNAs.

## TopoICSim


## Parrallel processing and big data

As of right now, parallel processing is only supported for the `combined` method of lncRNApred. The reason why the other algorithms aren't parallelized yet, is because of implementation difficulty regarding the amount and type of dependencies that the algorithms rely on. Possibly, in the future, parallel processing will be supported for other algorithms as well. It might however be possible to divide up the work with TopoICSim (on gene pair level). It runs for each unique pair of genes, which you may be arbitrarily be able to generate using the hidden `GAPGOM:::.unique_combos` function. No support is offered however in regards to trying to make this work.

## Other algorithms and performance

While other algorithms exist, they are not neccesarily included in the package directly. The performance of this package is however well tested in the Benchmarks vignette, in which other algorithms are also touched upon/compared.

## References